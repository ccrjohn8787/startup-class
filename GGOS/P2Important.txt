- 然后给一个unsorted slots with numbers，比如：【3,1,0,2,x，4】，x表示位置为空。每次只能移动数字到空的位置，不能直接两数字互换。让排序这个slots，并且唯一的空在最后，比如【0,1,2,3,4，x】。数字只包含 0到n-2
我一开始的算法就是写一个swap，然后用一个指针从0开始，去让每个数字跟他本身属于的位置做swap。每当i位置上的数字本身就是i，或者是空，我们就i+1.复杂度是O(n)因为每个数字最多只用swap一次。
之后发觉做swap会额外多操作一次，比如swap（i,j），我们实际上是先把i移到空，j移到i，i再从空移到j。但实际上我们只需要把相应位置原本占有者移到空位，再把目标数字移到他应在的位置，同时记录现在的空位变化到哪里了。这样就可以节省操作。实际上也是O(n)的复杂度，但肯定操作的数量是更少的。
空位排序那题很有意思。最直接的想法是先把空格移到最后，然后正常排序，但是交换的时候用空格作为临时存储。这样的缺点是没有利用只有0 - (n-2)的条件。可以这样做。看样例:
0 1 2 3 4 5 <-index
3 1 0 2 x 4 <-value
第一步：如果a[i] == i || a[i] == x, continue；如果不是的话，不断递归直到a[a[a[..a[i]]]] == i || x：
a[0] != 0, 所以查看：a[a[i]] = a[3] = 2 != 0, 所以继续：a[a[a[i]]] = a[a[3]] = a[2] = 0 == 0，递归停止。
第二步：如果该位为x，立一个flag。回溯，并且每一步将a[cur] = cur。如果flag为真，a[i] = x：
a[2] ＝ 2，回溯，a[3] = 3，回溯，a[0] = 0，flag为假，结束。
这一步可以看作在找环，然后先把环末尾放到空格，然后把环依次前移入位，最后还原空档。
第三步：i++接着走，重复第一步，直到结束。
这样做的复杂度是每个数字最多路过两遍，所以是个线性做法。

- 有3n个数围成一个环，取走其中一个的话会顺带去掉这个数相邻的两个数（这两个不计入总和），剩下的继续围成环，问取走n个数构成总和的最大值。
Take n meaning taking all
dp[i][j] = max value of taking from i to j
dp[i][j] = max(dp[i][k-1] + A[k] + dp[k+1][j]) for i <= k <= j

- 平面上一堆点，找两个点使由这两个点确定的直线平分剩余所有点。只说了下思路，并没有写代码。
我的思路是先找到最下面的点P，然后根据其余点与P的连线和P所在水平线的夹角找中位点。又说了可能有共线的情况，小哥说不用考虑共线。不知道思路对不对
每两个点确定的直线可以表示成ax+by+c = 0，对于其他不在直线上的点(x1,y1)一定会有ax1+by1+c < 0或者 ax1+by1+c > 0。平分所有点意味着大于0的点和小于0的点数量一样多。时间复杂度O(n^3)

- 集群各机器上有无序int stream，要找这些其median。 用quick selection的思想（pivot与其rank）。本来是在一个int[]中找median，现在是要在[int[], int[], int[]....]中找出median。从第一台机器找出local median后让其report pivot和rank，再把这信息发给所有其他机器让他们算出给定pivot 和小于pivot的value count，即为[pivot, count of values smaller than pivot]。这样一来回就知道下一步该怎么做，具体有三种情况。

- 在一个排序的不重复的环形的链表里插入一个数。-O(n) linear, think about edge cases (Search geeksForGeeks)

- - input:
G . . G
X . . .
. G . . 鏉ユ簮涓€浜�.涓夊垎鍦拌鍧�.
- G是终点，.是可走的点，X是不可走的点
output:
求出每个可走的点到终点的最短距离（每一步可上／下／左／右一步）
我的做法是经典的BFS。先构造一个距离矩阵，所有G的点对应的是距离为0，其他点为MAX_INT。然后将G的点放入Queue中进行BFS，修改距离矩阵。
    - [ ] follow up:
    - 如果每一步可走两步／三步怎么办？
如一步可走：左左，左上，右下，。。。
我说应该画出解空间树，然后DFS遍历解空间树，DFS的返回值是从该点出发最少需要几步到达一个G点。大叔说make sense。
    - Original:
        - can start from the destination and do bfs to all G
    - Follow up:
        - TODO
        - Important

- 写一个生日提示系统，每次查询时显示下一个谁过生日。这个有点偏system design, 比如他想看到你注意时区啊啥的很多细节（并不知道他是不是在黑我）。我直接说算法了，二分搜索。但是他似乎不理解我的版本的二分搜索。我用的二分搜索的版本是只改变一遍的那种

- 一个array,rearrange成为另一个array, 现在给了这两个array, 求是怎么变化成第二个array的. 挺简单的就用了Hashmap秒了...
然后问我,那现在给你原array,也知道了是怎么变化的了,所以我们现在可以用原array求出变化后的array对吗? 但是我要run这个method好多次比如k次, 怎么最快能求出array被rearrange了k次以后的结果? 最后我就推倒出求LCM..面完他亲切的用中文跟我说,我是他见过面的最好的,时间复杂度最低trade off也说的好. 谢谢小哥给了我信心~么么哒~
