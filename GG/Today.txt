1. Rearrange string k distance apart:
Given a non-empty string str and an integer k, rearrange the string such that the same characters are at least distance k from each other.
All input strings are given in lowercase letters. If it is not possible to rearrange the string, return an empty string "".
Example 1:
str = "aabbcc", k = 3
Result: "abcabc"
The same letters are at least distance 3 from each other.
Example 2:
str = "aaabc", k = 3 
Answer: ""
It is not possible to rearrange the string.
Example 3:
str = "aaadbbcc", k = 2
Answer: "abacabcd"
Another possible answer is: "abcabcda"
The same letters are at least distance 2 from each other.

2. Given a data stream input of non-negative integers a1, a2, ..., an, ..., summarize the numbers seen so far as a list of disjoint intervals.
For example, suppose the integers from the data stream are 1, 3, 7, 2, 6, ..., then the summary will be:
[1, 1]
[1, 1], [3, 3]
[1, 1], [3, 3], [7, 7]
[1, 3], [7, 7]
[1, 3], [6, 7]
Follow up:
What if there are lots of merges and the number of disjoint intervals are small compared to the data stream's size?

3. Six degrees of separation is the theory that everyone and everything is six or fewer steps away, by way of introduction, from any other person in the world, so that a chain of "a friend of a friend" statements can be made to connect any two people in a maximum of six steps.
Given a friendship relations, find the degrees of two people, return -1 if they can not been connected by friends of friends.

4. 给出一个矩阵，里面包含了各种character，要求找出其中连续的（比如A-B-C）相邻字母，并返回其最长路径。

5. 题目是给你一个board，里面存储user的信息，user有id和socre。
board有adduser(id, score)(返回add进去的user当前的rank), findByRank(k) (这个返回id)。
Add如果本身已经有id在board中，需要对这个id的score进行update。(BST insert, delete)

6. 给两个数字，代表起点和终点，请问最短的从起点到终点的路径，且最多经过一个（0）的arc

7. - 给一个float number P (e.g = 1.4523), 给定另外一个float number x，求x的sqrt是不是和P前k位相同。二分法改进一下。必要的时候用Math.ceiling()。

static float sqrt(float n)
        {
                float low=0,high=n;
               float mid=(low+high)/2;
               while(Math.abs(mid*mid-n)>0.00001) //IMPORTANT! 0.00001 is 10^-k
                {
                        if(mid*mid<n)
                                low=mid;
                        else if(mid*mid>n)
                                high=mid;
                        mid=(low+high)/2;
                }
                return mid;
        }

    - Thoughts:

        - k first digits of P and that plus 10^(-k-1) see if those square include x
        - Approach 2: the above solution
8. 给出一个 list of int, the target, 输出这个 list 中所用的数能否通过4则运算 得到 target。
boolean EvaluatesTo(list numbers, int target)
［2 3 6 9］ → 75(2+3)*(6+9) = 75 return true
［2 3 6 9］ －> 11 return false

9. - 给一个Game的schedule, 里面有每一个round和在这个round里面互相compete的players，比如Round1 A-B C-D
- Round2 A-D B-C.
- 这个schedule应该满足
1. 每个player每一个round只能play一次
2. 每一个player必须和其他所有对手都compete一次
3. 安排的round数应该是最少的
返回一个boolean值，看此Game schedule是不是valid的。

    - 1. min number of rounds. 如果是n is odd, min = n, otherwise(n is even) min = n-1.
    - 2. 每轮用hashset去重, 比如A-B, A-C由于A出现了,所以invalid
3. 检查invalid的match entry比如A-A B-B
4. hashmap保存所有已经出现的比赛,保证之后不出现

10. - 设计一个电话本系统，实现三个功能：查找号码 boolean isTaken()，添加号码 void takeNumber()，返回一个不在电话本里的没人用的号码 number giveMeANumber()。
    - [x] 我一开始说用HashMap，这样前两个函数的复杂度都是O(1)，第三个是O(n)。面试官说能不能优化第三个函数，我说用BST，每个节点多存一个value记录这个节点下还有几个available的号码，giveMeANumber()的实现只要沿着value>0的node往下找就行了。这样三个函数的复杂度都是O(lgn).
    - [x] Trie - each node also remembers how many available child nodes there are

11. - 大除法 输入是一个恶心到极点的string，比如1234567891011....（此后省略10000位）作为除数，和一个long作为被除数，返会所得的值.
    - public String divide（String divisor， long dividend）
    - 这题我的想法就是一段一段的取，大于dividend之后来除，得到的数加到stringbuilder里，余数跟后面加到一起，大于dividend之后在继续除，直到结束。不过其中有些细节要小心，不然会出runtime

12. - follow up是写addInterval和getAllIntervals的函数，LZ提出的先按start time sort再插入进去的方案被面试官说复杂度太高，想了想说，就sort一次，之后用binary search找第一个有overlap的interval和最后一个有overlap的interval,然后把中间的删了加一个新的
    - GetAllIntervals: 返回一个iterator，这个没怎么提到，光是讲addInterval了，感觉类里面弄一个成员变量maintain好list就行了，这个函数就返回list的Iterator就好了
    
13. - .input 是一个游戏的后台log (可以自己定义结构)：
- （1） update log，每条记录是 (time, player, role)，比如 (2016 March 11 13:10 UTC, 'mark', 'knight')
（2） play log，没条记录是（time，player），比如 (2016 March 12 12:10 UTC, 'mark')
output是每个role出现的次数。

    - playMap<player, List<time>>
    - roleMap<player, map<role, time>>
    - for each player:
     for each role’s start and end time:
          binary search first occurrence in playMap that’s after start
          binary search last occurrence in playMap that’s before end
